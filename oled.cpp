#include "oled.hpp"
#include <string.h>
#include "hardware/gpio.h"

// 5x7 font (ASCII 32-127)
static const uint8_t kFont5x7[96][5] = {
	{0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x5F,0x00,0x00},{0x00,0x07,0x00,0x07,0x00},{0x14,0x7F,0x14,0x7F,0x14},{0x24,0x2A,0x7F,0x2A,0x12},{0x23,0x13,0x08,0x64,0x62},{0x36,0x49,0x55,0x22,0x50},{0x00,0x05,0x03,0x00,0x00},{0x00,0x1C,0x22,0x41,0x00},{0x00,0x41,0x22,0x1C,0x00},{0x14,0x08,0x3E,0x08,0x14},{0x08,0x08,0x3E,0x08,0x08},{0x00,0x50,0x30,0x00,0x00},{0x08,0x08,0x08,0x08,0x08},{0x00,0x60,0x60,0x00,0x00},{0x20,0x10,0x08,0x04,0x02},{0x3E,0x51,0x49,0x45,0x3E},{0x00,0x42,0x7F,0x40,0x00},{0x42,0x61,0x51,0x49,0x46},{0x21,0x41,0x45,0x4B,0x31},{0x18,0x14,0x12,0x7F,0x10},{0x27,0x45,0x45,0x45,0x39},{0x3C,0x4A,0x49,0x49,0x30},{0x01,0x71,0x09,0x05,0x03},{0x36,0x49,0x49,0x49,0x36},{0x06,0x49,0x49,0x29,0x1E},{0x00,0x36,0x36,0x00,0x00},{0x00,0x56,0x36,0x00,0x00},{0x08,0x14,0x22,0x41,0x00},{0x14,0x14,0x14,0x14,0x14},{0x00,0x41,0x22,0x14,0x08},{0x02,0x01,0x51,0x09,0x06},{0x32,0x49,0x79,0x41,0x3E},{0x7E,0x11,0x11,0x11,0x7E},{0x7F,0x49,0x49,0x49,0x36},{0x3E,0x41,0x41,0x41,0x22},{0x7F,0x41,0x41,0x22,0x1C},{0x7F,0x49,0x49,0x49,0x41},{0x7F,0x09,0x09,0x09,0x01},{0x3E,0x41,0x49,0x49,0x7A},{0x7F,0x08,0x08,0x08,0x7F},{0x00,0x41,0x7F,0x41,0x00},{0x20,0x40,0x41,0x3F,0x01},{0x7F,0x08,0x14,0x22,0x41},{0x7F,0x40,0x40,0x40,0x40},{0x7F,0x02,0x0C,0x02,0x7F},{0x7F,0x04,0x08,0x10,0x7F},{0x3E,0x41,0x41,0x41,0x3E},{0x7F,0x09,0x09,0x09,0x06},{0x3E,0x41,0x51,0x21,0x5E},{0x7F,0x09,0x19,0x29,0x46},{0x46,0x49,0x49,0x49,0x31},{0x01,0x01,0x7F,0x01,0x01},{0x3F,0x40,0x40,0x40,0x3F},{0x1F,0x20,0x40,0x20,0x1F},{0x3F,0x40,0x38,0x40,0x3F},{0x63,0x14,0x08,0x14,0x63},{0x07,0x08,0x70,0x08,0x07},{0x61,0x51,0x49,0x45,0x43},{0x00,0x7F,0x41,0x41,0x00},{0x02,0x04,0x08,0x10,0x20},{0x00,0x41,0x41,0x7F,0x00},{0x04,0x02,0x01,0x02,0x04},{0x40,0x40,0x40,0x40,0x40},{0x00,0x01,0x02,0x04,0x00},{0x20,0x54,0x54,0x54,0x78},{0x7F,0x48,0x44,0x44,0x38},{0x38,0x44,0x44,0x44,0x20},{0x38,0x44,0x44,0x48,0x7F},{0x38,0x54,0x54,0x54,0x18},{0x08,0x7E,0x09,0x01,0x02},{0x0C,0x52,0x52,0x52,0x3E},{0x7F,0x08,0x04,0x04,0x78},{0x00,0x44,0x7D,0x40,0x00},{0x20,0x40,0x44,0x3D,0x00},{0x7F,0x10,0x28,0x44,0x00},{0x00,0x41,0x7F,0x40,0x00},{0x7C,0x04,0x18,0x04,0x78},{0x7C,0x08,0x04,0x04,0x78},{0x38,0x44,0x44,0x44,0x38},{0x7C,0x14,0x14,0x14,0x08},{0x08,0x14,0x14,0x18,0x7C},{0x7C,0x08,0x04,0x04,0x08},{0x48,0x54,0x54,0x54,0x20},{0x04,0x3F,0x44,0x40,0x20},{0x3C,0x40,0x40,0x20,0x7C},{0x1C,0x20,0x40,0x20,0x1C},{0x3C,0x40,0x30,0x40,0x3C},{0x44,0x28,0x10,0x28,0x44},{0x0C,0x50,0x50,0x50,0x3C},{0x44,0x64,0x54,0x4C,0x44},{0x00,0x08,0x36,0x41,0x00},{0x00,0x00,0x7F,0x00,0x00},{0x00,0x41,0x36,0x08,0x00},{0x10,0x08,0x08,0x10,0x08},{0x78,0x46,0x41,0x46,0x78}
};

OledDisplay::OledDisplay(i2c_inst_t* i2c_port, uint sda_pin, uint scl_pin, uint8_t addr,
						 uint8_t width, uint8_t height)
	: i2c_port(i2c_port), sda_pin(sda_pin), scl_pin(scl_pin), addr(addr), width(width), height(height) {
	size_t buf_size = (size_t)width * (size_t)height / 8;
	if (buf_size > kMaxBuffer) buf_size = kMaxBuffer;
	memset(buffer, 0, buf_size);
}

bool OledDisplay::init() {
	i2c_init(i2c_port, 400000);
	gpio_set_function(sda_pin, GPIO_FUNC_I2C);
	gpio_set_function(scl_pin, GPIO_FUNC_I2C);
	gpio_pull_up(sda_pin);
	gpio_pull_up(scl_pin);

	static const uint8_t init_cmds[] = {
		0xAE,       // display off
		0xD5, 0x80, // clock divide
		0xA8, 0x3F, // multiplex ratio for 64px
		0xD3, 0x00, // display offset
		0x40,       // start line
		0x8D, 0x14, // charge pump on
		0x20, 0x00, // horizontal addressing
		0xA1,       // segment remap
		0xC8,       // COM scan direction
		0xDA, 0x12, // COM pins
		0x81, 0xCF, // contrast
		0xD9, 0xF1, // pre-charge
		0xDB, 0x40, // Vcom detect
		0xA4,       // resume RAM display
		0xA6,       // normal display
		0xAF        // display on
	};

	sendCommands(init_cmds, sizeof(init_cmds));
	clear();
	update();
	return true;
}

void OledDisplay::sendCommand(uint8_t cmd) {
	uint8_t data[2] = {0x00, cmd};
	i2c_write_blocking(i2c_port, addr, data, 2, false);
}

void OledDisplay::sendCommands(const uint8_t* cmds, size_t count) {
	for (size_t i = 0; i < count; ++i) {
		sendCommand(cmds[i]);
	}
}

void OledDisplay::clear(bool color) {
	size_t buf_size = (size_t)width * (size_t)height / 8;
	if (buf_size > kMaxBuffer) buf_size = kMaxBuffer;
	memset(buffer, color ? 0xFF : 0x00, buf_size);
}

void OledDisplay::drawPixel(int x, int y, bool color) {
	if (x < 0 || y < 0 || x >= width || y >= height) return;
	size_t index = (size_t)x + (size_t)(y / 8) * width;
	uint8_t mask = 1u << (y & 7);
	if (color) buffer[index] |= mask; else buffer[index] &= ~mask;
}

void OledDisplay::drawRect(int x, int y, int w, int h, bool color) {
	if (w <= 0 || h <= 0) return;
	for (int dx = 0; dx < w; ++dx) {
		drawPixel(x + dx, y, color);
		drawPixel(x + dx, y + h - 1, color);
	}
	for (int dy = 0; dy < h; ++dy) {
		drawPixel(x, y + dy, color);
		drawPixel(x + w - 1, y + dy, color);
	}
}

void OledDisplay::fillRect(int x, int y, int w, int h, bool color) {
	if (w <= 0 || h <= 0) return;
	for (int dy = 0; dy < h; ++dy) {
		for (int dx = 0; dx < w; ++dx) {
			drawPixel(x + dx, y + dy, color);
		}
	}
}

void OledDisplay::drawChar(int x, int y, char c, bool color) {
	if (c < 32 || c > 127) return;
	const uint8_t* bitmap = kFont5x7[c - 32];
	for (int col = 0; col < 5; ++col) {
		uint8_t line = bitmap[col];
		for (int row = 0; row < 7; ++row) {
			if (line & (1 << row)) {
				// draw glyph pixels and leave background untouched!!!
				drawPixel(x + col, y + row, color);
			}
		}
	}
}

void OledDisplay::drawString(int x, int y, const char* str, bool color) {
	int cursor_x = x;
	while (*str) {
		if (*str == '\n') {
			cursor_x = x;
			y += 8;
			++str;
			continue;
		}
		drawChar(cursor_x, y, *str, color);
		cursor_x += 6; // 5px char + 1px space
		++str;
	}
}

void OledDisplay::drawImage(int x, int y, int size, const bool* pixelMap) {
	for (int row = 0; row < size; row++) {
		for (int col = 0; col < size; col++) {
			if (pixelMap[row * size + col]) {
				drawPixel(x + col, y + row, true);
			}
		}
	}
}

void OledDisplay::sendBufferPage(uint8_t page) {
	if (page >= height / 8) return;
	uint8_t cmds[] = {
		static_cast<uint8_t>(0xB0 | page), // set page
		0x00,                              // lower column start
		0x10                               // higher column start
	};
	sendCommands(cmds, sizeof(cmds));

	// byte 0x40 for data stream
	uint8_t tmp[1 + 128];
	tmp[0] = 0x40;
	size_t offset = (size_t)page * width;
	size_t len = width;
	if (len > 128) len = 128;
	memcpy(tmp + 1, buffer + offset, len);
	i2c_write_blocking(i2c_port, addr, tmp, len + 1, false);
}

void OledDisplay::update() {
	for (uint8_t page = 0; page < height / 8; ++page) {
		sendBufferPage(page);
	}
}
